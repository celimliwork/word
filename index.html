<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kelime Kartlarƒ± - √ñƒürenme Sistemi</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìö Kelime Kartlarƒ±</h1>
            <p>ƒ∞ngilizce Kelime √ñƒürenme Sistemi</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="modeSelect">√ñƒürenme Modu</label>
                <select id="modeSelect">
                    <option value="full">Tam √ñƒürenme Modu</option>
                    <option value="en-tr">ƒ∞ngilizce ‚Üí T√ºrk√ße</option>
                    <option value="tr-en">T√ºrk√ße ‚Üí ƒ∞ngilizce</option>
                </select>
            </div>

            <div class="control-group">
                <label for="dateFilter">Tarih Filtresi</label>
                    <select id="dateFilter">
                        <option value="all">T√ºm√ºn√º G√∂ster</option>
                    <option value="today" >Bug√ºn Eklenenler</option>
                    </select>
                </div>
            </div>

        <div class="cards-container" id="cardsContainer">
            <!-- Kartlar buraya eklenecek -->
        </div>

        <div class="pagination" id="pagination">
            <div class="pagination-info" id="paginationInfo"></div>
            <div class="pagination-buttons">
                <button class="pagination-btn" id="prevBtn">√ñnceki</button>
                <button class="pagination-btn" id="nextBtn">Sonraki</button>
            </div>
        </div>

        <div class="stats" id="stats"></div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        let wordsData = [];
        let filteredWordsData = [];
        let currentPage = 1;
        const CARDS_PER_PAGE = 20;
        let currentMode = 'full';
        let selectedDate = 'all';
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 500;
        const STORAGE_KEY = 'wordCardAppState';

        // ==================== LOCALSTORAGE ====================
        function saveState() {
            const state = {
                currentMode: currentMode,
                selectedDate: selectedDate,
                currentPage: currentPage
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (error) {
                console.error('localStorage kayƒ±t hatasƒ±:', error);
            }
        }

        function loadState() {
            try {
                const savedState = localStorage.getItem(STORAGE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (state.currentMode) currentMode = state.currentMode;
                    if (state.selectedDate) selectedDate = state.selectedDate;
                    if (state.currentPage) currentPage = state.currentPage;
                }
            } catch (error) {
                console.error('localStorage y√ºkleme hatasƒ±:', error);
            }
        }

        // ==================== DATA LOADING ====================
        let wordsIndex = null;
        let wordsIndexLoaded = false;
        let dateFilterInitialized = false;

        async function loadWordsIndex() {
            // Eƒüer zaten y√ºklendiyse tekrar y√ºkleme
            if (wordsIndexLoaded && wordsIndex) {
                return true;
            }
            
            try {
                const response = await fetch('words_index.json');
                wordsIndex = await response.json();
                wordsIndexLoaded = true;
                return true;
            } catch (error) {
                console.error('Index dosyasƒ± y√ºklenirken hata:', error);
                return false;
            }
        }

        function getDateFromDateStr(dateStr) {
            // DD.MM.YYYY formatƒ±ndan YYYY_MM_DD √ßƒ±kar
            try {
                const parts = dateStr.split('.');
                if (parts.length === 3) {
                    const day = parts[0];
                    const month = parts[1];
                    const year = parts[2];
                    return `${year}_${month}_${day}`;
                }
            } catch (e) {
                console.error('Tarih parse hatasƒ±:', e);
            }
            return null;
        }

        async function loadWordsFromFile(filename) {
            try {
                const response = await fetch(filename);
                
                // 404 veya diƒüer hata durumlarƒ±nƒ± kontrol et
                if (!response.ok) {
                    console.warn(`${filename} bulunamadƒ± (${response.status})`);
                    return [];
                }
                
                // Content-Type kontrol√º yap
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    console.warn(`${filename} JSON formatƒ±nda deƒüil`);
                    return [];
                }
                
                const data = await response.json();
                return Array.isArray(data) ? data : [];
            } catch (error) {
                // JSON parse hatasƒ± veya network hatasƒ±
                if (error instanceof SyntaxError) {
                    console.warn(`${filename} JSON parse hatasƒ± - dosya bulunamadƒ± veya ge√ßersiz format`);
                } else {
                    console.warn(`${filename} y√ºklenirken hata:`, error);
                }
                return [];
            }
        }

        async function loadWords() {
            try {
                // Index dosyasƒ±nƒ± y√ºkle
                const indexLoaded = await loadWordsIndex();
                
                if (!indexLoaded || !wordsIndex || wordsIndex.files.length === 0) {
                    // Index yoksa eski words.json'u dene
                    console.log('Index bulunamadƒ±, words.json y√ºkleniyor...');
                    const response = await fetch('words.json');
                    wordsData = await response.json();
                } else {
                    // Tarih filtresine g√∂re dosya y√ºkle
                    if (selectedDate === 'all') {
                        // T√ºm dosyalarƒ± y√ºkle
                        wordsData = [];
                        for (const filename of wordsIndex.files) {
                            const fileData = await loadWordsFromFile(filename);
                            wordsData = wordsData.concat(fileData);
                        }
                    } else if (selectedDate === 'today') {
                        // Bug√ºn√ºn tarihine g√∂re dosya y√ºkle
                        const today = new Date();
                        const todayStr = `${String(today.getDate()).padStart(2, '0')}.${String(today.getMonth() + 1).padStart(2, '0')}.${today.getFullYear()}`;
                        const dateKey = getDateFromDateStr(todayStr);
                        const filename = `words_${dateKey}.json`;
                        wordsData = await loadWordsFromFile(filename);
                    } else {
                        // Se√ßilen tarihe g√∂re dosya y√ºkle
                        const dateKey = getDateFromDateStr(selectedDate);
                        if (dateKey) {
                            const filename = `words_${dateKey}.json`;
                            wordsData = await loadWordsFromFile(filename);
                            
                            // Dosya yoksa veya bo≈üsa kullanƒ±cƒ±ya bilgi ver
                            if (wordsData.length === 0) {
                                console.info(`${selectedDate} tarihi i√ßin kelime bulunamadƒ±.`);
                            }
                        } else {
                            wordsData = [];
                        }
                    }
                }

                // Tarih filtresini sadece ilk y√ºklemede olu≈ütur
                // Tarih deƒüi≈ütiƒüinde dropdown'ƒ± yeniden olu≈üturmaya gerek yok
                if (!dateFilterInitialized) {
                    initializeDateFilter();
                    setupDateFilterListener();
                    dateFilterInitialized = true;
                } else {
                    // Sadece se√ßili deƒüeri g√ºncelle
                    const dateFilter = document.getElementById('dateFilter');
                    if (dateFilter) {
                        dateFilter.value = selectedDate;
                    }
                }
                
                applyFilters();
                renderCards();
                updateStats();
            } catch (error) {
                console.error('Dosya y√ºklenirken hata:', error);
                document.getElementById('cardsContainer').innerHTML = 
                    '<div class="empty-state"><div class="empty-state-icon">‚ùå</div><div class="empty-state-text">Dosya y√ºklenirken bir hata olu≈ütu.</div></div>';
            }
        }

        // ==================== DATE FILTER ====================
        function initializeDateFilter() {
            const dateFilter = document.getElementById('dateFilter');
            
            // Mevcut se√ßenekleri temizle (sadece "T√ºm√ºn√º G√∂ster" kalsƒ±n)
            dateFilter.innerHTML = '<option value="all">T√ºm√ºn√º G√∂ster</option>';
            
            // Bug√ºn√ºn tarihini al (DD.MM.YYYY formatƒ±nda)
            const today = new Date();
            const todayStr = `${String(today.getDate()).padStart(2, '0')}.${String(today.getMonth() + 1).padStart(2, '0')}.${today.getFullYear()}`;
            
            // Bug√ºn se√ßeneƒüini ekle
            const todayOption = document.createElement('option');
            todayOption.value = 'today';
            todayOption.textContent = `Bug√ºn (${todayStr})`;
            dateFilter.appendChild(todayOption);
            
            // Tarih se√ßeneklerini olu≈ütur
            const dateSet = new Set(); // Tekrar eden tarihleri √∂nlemek i√ßin
            
            // √ñnce dates alanƒ±ndan tarihleri al
            if (wordsIndex && wordsIndex.dates && Array.isArray(wordsIndex.dates)) {
                wordsIndex.dates.forEach(dateKey => {
                    // YYYY_MM_DD formatƒ±ndan DD.MM.YYYY formatƒ±na √ßevir
                    const parts = dateKey.split('_');
                    if (parts.length === 3) {
                        const year = parts[0];
                        const month = parts[1];
                        const day = parts[2];
                        const dateStr = `${day}.${month}.${year}`;
                        if (!dateSet.has(dateStr) && dateStr !== todayStr) {
                            dateSet.add(dateStr);
                            const option = document.createElement('option');
                            option.value = dateStr;
                            option.textContent = dateStr;
                            dateFilter.appendChild(option);
                        }
                    }
                });
            }
            
            // Eƒüer dates yoksa, dosya isimlerinden tarihleri √ßƒ±kar
            if (wordsIndex && wordsIndex.files && Array.isArray(wordsIndex.files)) {
                wordsIndex.files.forEach(filename => {
                    // words_YYYY_MM_DD.json formatƒ±ndan tarih √ßƒ±kar
                    const match = filename.match(/words_(\d{4})_(\d{2})_(\d{2})\.json/);
                    if (match) {
                        const year = match[1];
                        const month = match[2];
                        const day = match[3];
                        const dateStr = `${day}.${month}.${year}`;
                        if (!dateSet.has(dateStr) && dateStr !== todayStr) {
                            dateSet.add(dateStr);
                            const option = document.createElement('option');
                            option.value = dateStr;
                            option.textContent = dateStr;
                            dateFilter.appendChild(option);
                        }
                    }
                });
            }
            
            // Eski format (ay bazlƒ±) - geriye d√∂n√ºk uyumluluk
            if (wordsIndex && wordsIndex.months && Array.isArray(wordsIndex.months)) {
                wordsIndex.months.forEach(monthKey => {
                    const parts = monthKey.split('_');
                    if (parts.length === 2) {
                        const year = parts[0];
                        const month = parts[1];
                        const dateStr = `01.${month}.${year}`;
                        if (!dateSet.has(dateStr) && dateStr !== todayStr) {
                            dateSet.add(dateStr);
                            const option = document.createElement('option');
                            option.value = dateStr;
                            option.textContent = `${month}.${year}`;
                            dateFilter.appendChild(option);
                        }
                    }
                });
            }
            
            // Index yoksa mevcut wordsData'dan tarihleri al
            if (wordsData && wordsData.length > 0) {
                const uniqueDates = [...new Set(wordsData.map(word => word.date).filter(date => date))].sort();
                uniqueDates.forEach(date => {
                    if (!dateSet.has(date) && date !== todayStr) {
                        dateSet.add(date);
                        const option = document.createElement('option');
                        option.value = date;
                        option.textContent = date;
                        dateFilter.appendChild(option);
                    }
                });
            }
            
            // Tarihleri sƒ±rala (en yeni en √ºstte)
            const options = Array.from(dateFilter.options);
            const allOption = options[0]; // "T√ºm√ºn√º G√∂ster"
            const todayOpt = options[1]; // "Bug√ºn"
            const dateOptions = options.slice(2).sort((a, b) => {
                // DD.MM.YYYY formatƒ±nƒ± kar≈üƒ±la≈ütƒ±r
                const dateA = a.value.split('.').reverse().join('');
                const dateB = b.value.split('.').reverse().join('');
                return dateB.localeCompare(dateA); // En yeni en √ºstte
            });
            
            dateFilter.innerHTML = '';
            dateFilter.appendChild(allOption);
            if (todayOpt) dateFilter.appendChild(todayOpt);
            dateOptions.forEach(opt => dateFilter.appendChild(opt));

            // Kaydedilmi≈ü deƒüeri se√ß
            dateFilter.value = selectedDate;
        }
        
        // Date filter event listener'ƒ± ayrƒ± bir fonksiyonda
        function setupDateFilterListener() {
            const dateFilter = document.getElementById('dateFilter');
            
            // √ñnceki listener'larƒ± kaldƒ±rmak i√ßin clone yap
            const newDateFilter = dateFilter.cloneNode(true);
            dateFilter.parentNode.replaceChild(newDateFilter, dateFilter);
            
            // Yeni listener ekle
            const finalDateFilter = document.getElementById('dateFilter');
            finalDateFilter.addEventListener('change', async (e) => {
                selectedDate = e.target.value;
                currentPage = 1;
                // Tarih deƒüi≈ütiƒüinde yeni dosyayƒ± y√ºkle
                await loadWords();
                saveState(); // Durumu kaydet
            });
        }

        // ==================== MODE SELECTION ====================
        function initializeModeSelect() {
            const modeSelect = document.getElementById('modeSelect');
            
            // Kaydedilmi≈ü deƒüeri se√ß
            modeSelect.value = currentMode;
            
            modeSelect.addEventListener('change', (e) => {
                currentMode = e.target.value;
                currentPage = 1;
                renderCards();
                saveState(); // Durumu kaydet
            });
        }

        // ==================== FILTERING ====================
        function applyFilters() {
            // Dosya zaten tarihe g√∂re y√ºklendiƒüi i√ßin sadece kopyala
            // Eƒüer "all" se√ßiliyse t√ºm kelimeler, deƒüilse sadece se√ßilen tarihteki kelimeler
            filteredWordsData = [...wordsData];
            
            // Ek filtreleme sadece "all" modunda gerekli deƒüil √ß√ºnk√º dosya zaten tarihe g√∂re y√ºklendi
            // Ama yine de kontrol edelim (g√ºvenlik i√ßin)
            if (selectedDate === 'today') {
                const today = new Date();
                const todayStr = `${String(today.getDate()).padStart(2, '0')}.${String(today.getMonth() + 1).padStart(2, '0')}.${today.getFullYear()}`;
                filteredWordsData = filteredWordsData.filter(word => word.date === todayStr);
            } else if (selectedDate !== 'all') {
                // Se√ßilen tarihe g√∂re filtrele (dosya zaten y√ºklendi ama yine de kontrol et)
                filteredWordsData = filteredWordsData.filter(word => word.date === selectedDate);
            }
            
            // Sayfa numarasƒ±nƒ±n ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et
            const totalPages = Math.ceil(filteredWordsData.length / CARDS_PER_PAGE);
            if (currentPage > totalPages && totalPages > 0) {
                currentPage = totalPages;
            } else if (currentPage < 1) {
                currentPage = 1;
            }
        }

        // ==================== CARD RENDERING ====================
        function renderCards() {
            const container = document.getElementById('cardsContainer');
            const startIndex = (currentPage - 1) * CARDS_PER_PAGE;
            const endIndex = startIndex + CARDS_PER_PAGE;
            const pageData = filteredWordsData.slice(startIndex, endIndex);

            if (pageData.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì≠</div><div class="empty-state-text">Bu filtreye uygun kelime bulunamadƒ±.</div></div>';
                return;
            }

            container.innerHTML = pageData.map(word => createCardHTML(word)).join('');
            
            // Event listener'larƒ± ekle
            attachCardListeners();
            updatePagination();
        }

        function createCardHTML(word) {
            const cardId = `card-${word.word.replace(/\s+/g, '-')}`;
            const typeClass = word.type ? word.type.replace(/\s+/g, '').replace(/[^a-zA-Z0-9]/g, '') : '';
            
            let cardHTML = `<div class="word-card" id="${cardId}" data-word="${word.word}">`;
            
            // Moda g√∂re i√ßerik
            if (currentMode === 'full') {
                cardHTML += createFullModeHTML(word, typeClass);
            } else if (currentMode === 'en-tr') {
                cardHTML += createEnTrModeHTML(word, typeClass);
            } else if (currentMode === 'tr-en') {
                cardHTML += createTrEnModeHTML(word, typeClass);
            }
            
            cardHTML += '</div>';
            return cardHTML;
        }

        function createFullModeHTML(word, typeClass) {
            let html = `
                ${word.type ? `<span class="type-badge type-${typeClass}">${word.type}</span>` : ''}
                <div class="card-field">
                    <div class="word-main">
                        <span class="word-text">${word.word || '-'}</span>
                        ${word.word ? `<button class="sound-btn" onclick="speakText('${word.word.replace(/'/g, "\\'")}')" title="Seslendir">üîä</button>` : ''}
                    </div>
                    ${word.pronunciation ? `<div class="pronunciation">${word.pronunciation}</div>` : ''}
                </div>
                
                ${word.meaning ? `<div class="card-field">
                    <div class="field-value">${word.meaning}</div>
                </div>` : ''}
            `;

            // Fiil formlarƒ±
            if (word.v2?.form || word.v3?.form || word.gerundInfinitive) {
                html += '<div class="card-field"><div class="verb-forms">';
                if (word.v2?.form) {
                    html += `<div class="verb-form-item"><span class="verb-form-label">V2:</span>${word.v2.form}${word.v2.pronunciation ? ` <span style="color: #6c757d; font-style: italic;">(${word.v2.pronunciation})</span>` : ''}</div>`;
                }
                if (word.v3?.form) {
                    html += `<div class="verb-form-item"><span class="verb-form-label">V3:</span>${word.v3.form}${word.v3.pronunciation ? ` <span style="color: #6c757d; font-style: italic;">(${word.v3.pronunciation})</span>` : ''}</div>`;
                }
                if (word.gerundInfinitive) {
                    html += `<div class="verb-form-item"><span class="verb-form-label">Gerund/Infinitive:</span>${word.gerundInfinitive}</div>`;
                }
                html += '</div></div>';
            }

            // √ñrnek c√ºmleler
            if (word.examples && word.examples.length > 0) {
                html += '<div class="card-field"><div class="examples-list">';
                word.examples.forEach(ex => {
                    html += `
                        <div class="example-item">
                            <div class="example-sentence">
                                ${ex.sentence || '-'}
                                ${ex.sentence ? `<button class="sound-btn" style="width: 28px; height: 28px; font-size: 1rem; margin-left: auto;" onclick="speakText('${(ex.sentence || '').replace(/'/g, "\\'")}')" title="Seslendir">üîä</button>` : ''}
                </div>
                            <div class="example-meaning">${ex.meaning || '-'}</div>
            </div>
                    `;
                });
                html += '</div></div>';
            }

            html += `<div class="card-field"><div class="field-label">Tarih</div><div class="field-value">${word.date || '-'}</div></div>`;
            
            return html;
        }

        function createEnTrModeHTML(word, typeClass) {
            let html = `
                ${word.type ? `<span class="type-badge type-${typeClass}">${word.type}</span>` : ''}
                <div class="card-field">
                    <div class="word-main">
                        <span class="word-text">${word.word || '-'}</span>
                        ${word.word ? `<button class="sound-btn" onclick="speakText('${word.word.replace(/'/g, "\\'")}')" title="Seslendir">üîä</button>` : ''}
            </div>
                    ${word.pronunciation ? `<div class="pronunciation">${word.pronunciation}</div>` : ''}
        </div>

                <div class="card-field hidden-field" data-reveal="tr">
                    <div class="field-value hidden">G√∂ster</div>
                    <div class="field-value" style="display: none;">${word.meaning || '-'}</div>
        </div>
            `;

            // √ñrnek c√ºmleler
            if (word.examples && word.examples.length > 0) {
                html += '<div class="card-field"><div class="examples-list">';
                word.examples.forEach(ex => {
                    html += `
                        <div class="example-item">
                            <div class="example-sentence">
                                ${ex.sentence || '-'}
                                ${ex.sentence ? `<button class="sound-btn" style="width: 28px; height: 28px; font-size: 1rem; margin-left: auto;" onclick="speakText('${(ex.sentence || '').replace(/'/g, "\\'")}')" title="Seslendir">üîä</button>` : ''}
                </div>
                            <div class="example-meaning hidden-field" data-reveal="tr">
                                <span class="field-value hidden">G√∂rmek i√ßin tƒ±klayƒ±n</span>
                                <span class="field-value" style="display: none;">${ex.meaning || '-'}</span>
            </div>
            </div>
                    `;
                });
                html += '</div></div>';
            }
            
            return html;
        }

        function createTrEnModeHTML(word, typeClass) {
            let html = `
                ${word.type ? `<span class="type-badge type-${typeClass} hidden-field" data-reveal="en" style="display: none;">${word.type}</span>` : ''}
                <div class="card-field hidden-field" data-reveal="en">
                    <div class="word-main">
                        <span class="word-text hidden">G√∂ster</span>
                        <span class="word-text" style="display: none;">${word.word || '-'}</span>
                        ${word.word ? `<button class="sound-btn" style="display: none;" onclick="speakText('${word.word.replace(/'/g, "\\'")}')" title="Seslendir">üîä</button>` : ''}
                    </div>
                    <div class="pronunciation" style="display: none;">${word.pronunciation || ''}</div>
        </div>

                <div class="card-field">
                    <div class="field-value">${word.meaning || '-'}</div>
        </div>
            `;

            // √ñrnek c√ºmleler
            if (word.examples && word.examples.length > 0) {
                html += '<div class="card-field"><div class="examples-list">';
                word.examples.forEach(ex => {
                    html += `
                        <div class="example-item">
                            <div class="example-sentence hidden-field" data-reveal="en">
                                <span class="hidden" style="display: inline;">G√∂rmek i√ßin tƒ±klayƒ±n</span>
                                <span class="hidden-content" style="display: none;">${ex.sentence || '-'}</span>
                                ${ex.sentence ? `<button class="sound-btn hidden-content" style="width: 28px; height: 28px; font-size: 1rem; margin-left: auto; display: none;" onclick="speakText('${(ex.sentence || '').replace(/'/g, "\\'")}')" title="Seslendir">üîä</button>` : ''}
    </div>
                            <div class="example-meaning">${ex.meaning || '-'}</div>
                        </div>
                    `;
                });
                html += '</div></div>';
            }
            
            return html;
        }

        // ==================== CARD INTERACTIONS ====================
        function attachCardListeners() {
            const cards = document.querySelectorAll('.word-card');
            cards.forEach(card => {
                // Tap/Click
                card.addEventListener('click', (e) => {
                    if (e.target.classList.contains('sound-btn')) return;
                    revealHiddenFields(card);
                });

                // Long press
                card.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('sound-btn')) return;
                    longPressTimer = setTimeout(() => {
                        revealHiddenFields(card);
                    }, LONG_PRESS_DURATION);
                });

                card.addEventListener('touchend', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });

                card.addEventListener('touchcancel', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });

                // Mouse long press (desktop)
                card.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('sound-btn')) return;
                    longPressTimer = setTimeout(() => {
                        revealHiddenFields(card);
                    }, LONG_PRESS_DURATION);
                });

                card.addEventListener('mouseup', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });

                card.addEventListener('mouseleave', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
            });
        }

        function revealHiddenFields(card) {
            card.classList.add('revealed');
            const hiddenFields = card.querySelectorAll('.hidden-field');
            hiddenFields.forEach(field => {
                // Gizli placeholder'larƒ± gizle
                const hiddenElements = field.querySelectorAll('.hidden');
                hiddenElements.forEach(el => el.style.display = 'none');
                
                // Gizli i√ßerikleri g√∂ster (hidden-content class'ƒ± veya display: none olanlar)
                const hiddenContent = field.querySelectorAll('.hidden-content');
                hiddenContent.forEach(el => {
                    el.style.display = '';
                });
                
                // T√ºm gizli elementleri bul ve g√∂ster (display: none olanlar, hidden class'ƒ± olmayanlar)
                const allElements = field.querySelectorAll('*');
                allElements.forEach(el => {
                    if (el.style.display === 'none' && !el.classList.contains('hidden')) {
                        // Eƒüer button ise inline-flex, span ise inline, diƒüerleri i√ßin uygun display
                        if (el.classList.contains('sound-btn')) {
                            el.style.display = 'flex';
                        } else if (el.tagName === 'SPAN' || el.tagName === 'DIV') {
                            el.style.display = '';
            } else {
                            el.style.display = '';
                        }
                    }
                });
                
                // Field'ƒ±n kendisi gizliyse g√∂ster
                if (field.style.display === 'none') {
                    field.style.display = '';
                }
            });
        }

        // ==================== SPEECH API ====================
        function speakText(text) {
            if (!text || text === '-') return;
            
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                utterance.pitch = 1;
                window.speechSynthesis.speak(utterance);
            } else {
                alert('Tarayƒ±cƒ±nƒ±z seslendirme √∂zelliƒüini desteklemiyor.');
            }
        }

        // ==================== PAGINATION ====================
        function updatePagination() {
            const totalPages = Math.ceil(filteredWordsData.length / CARDS_PER_PAGE);
            const startIndex = (currentPage - 1) * CARDS_PER_PAGE + 1;
            const endIndex = Math.min(currentPage * CARDS_PER_PAGE, filteredWordsData.length);
            
            document.getElementById('paginationInfo').textContent = 
                `Sayfa ${currentPage} / ${totalPages} (${startIndex}-${endIndex} / ${filteredWordsData.length})`;
            
            document.getElementById('prevBtn').disabled = currentPage === 1;
            document.getElementById('nextBtn').disabled = currentPage >= totalPages;
        }

        function initializePagination() {
            document.getElementById('prevBtn').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderCards();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    saveState(); // Durumu kaydet
                }
            });

            document.getElementById('nextBtn').addEventListener('click', () => {
                const totalPages = Math.ceil(filteredWordsData.length / CARDS_PER_PAGE);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderCards();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                    saveState(); // Durumu kaydet
                }
            });
        }

        // ==================== STATS ====================
        function updateStats() {
            const statsDiv = document.getElementById('stats');
            const totalWords = wordsData.length;
            const filteredCount = filteredWordsData.length;
            
            let statsText = `Toplam ${totalWords} kelime`;
            if (selectedDate !== 'all') {
                statsText += ` | Filtrelenmi≈ü: ${filteredCount} kelime`;
            } else {
                statsText += ` | G√∂sterilen: ${filteredCount} kelime`;
            }
            
            statsDiv.textContent = statsText;
        }

        // ==================== INITIALIZATION ====================
        function init() {
            loadState(); // ƒ∞lk y√ºklemede kaydedilmi≈ü durumu y√ºkle
            initializeModeSelect();
            initializePagination();
        loadWords();
        }

        // Sayfa y√ºklendiƒüinde ba≈ülat
        init();
    </script>
</body>
</html>
